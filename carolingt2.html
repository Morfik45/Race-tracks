<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Caroling</title>
  <style>
    /* Transparent background so the app can be embedded in-game as an overlay */
    html,body{height:100%;margin:0;background:transparent}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#eaeaea}

    /* Floating settings button */
    #openSettings{
      position:fixed;right:12px;top:12px;z-index:9999;background:rgba(0,0,0,0.45);backdrop-filter:blur(4px);
      border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;cursor:pointer
    }

    /* Settings panel (draggable) */
    #settings{
      position:fixed;right:12px;top:56px;width:320px;z-index:9999;background:rgba(10,10,10,0.72);
      border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 8px 30px rgba(0,0,0,0.6);
      display:none;color:#ddd
    }
    #settings h2{margin:0 0 8px;font-size:16px}
    .row{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
    .row label{font-size:13px}
    .toggle{cursor:pointer;padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}

    /* small helper */
    .small{font-size:12px;opacity:0.8}
    select,input[type=range]{width:100%}

    #status {
      position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);
      color:#dfe6ff;font-size:13px;z-index:9999
    }

    /* Countdown overlay */
    #countdownOverlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:72px;color:white;text-shadow:0 2px 12px rgba(0,0,0,0.8);display:none;z-index:10000}

    /* tiny controls inside settings */
    .controls{margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:8px}
    button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:inherit;cursor:pointer}
  </style>
</head>
<body>
  <button id="openSettings">⚙️ Caroling audio settings</button>

  <div id="settings" role="dialog" aria-label="Caroling settings">
    <h2>Caroling audio app</h2>
    <div class="row"><label>Enabled (master)</label><button id="enabledBtn" class="toggle">Off</button></div>
    <div class="row"><label>Auto-start on E press</label><button id="autoStartBtn" class="toggle">On</button></div>
    <div class="row"><label>Metronome</label><button id="metronomeBtn" class="toggle">On</button></div>
    <div class="row"><label>Music</label><button id="musicBtn" class="toggle">Off</button></div>
    <div class="row"><label>Countdown before start</label><button id="countdownBtn" class="toggle">On</button></div>

    <div style="margin-top:10px">
      <label class="small">BPM</label>
      <input id="bpmRange" type="range" min="40" max="200" value="85">
      <div class="small" style="text-align:right" id="bpmVal">85 BPM</div>
    </div>

    <div style="margin-top:10px">
      <label class="small">Sound preset</label>
      <select id="preset">
        <option value="classic">Classic clicks (metronome + beeps)</option>
        <option value="soft">Soft wood + chime</option>
        <option value="synth">Synth clicks (electronic)</option>
      </select>
    </div>

    <div style="margin-top:10px">
      <label class="small">Volume</label>
      <input id="volume" type="range" min="0" max="1" step="0.01" value="0.6">
    </div>

    <div class="controls">
      <button id="testSound">Test sound</button>
      <button id="stopAll">Stop</button>
      <button id="closeSettings">Close</button>
      <button id="resetSettings">Reset</button>
    </div>

    <div style="margin-top:8px;font-size:12px;color:#bfc7d6;">When enabled, press <strong>E</strong> in-game to trigger the app. While active the app listens to D F J K and plays assigned sounds for each key.</div>
  </div>

  <div id="status">Status: <span id="statTxt">Disabled</span></div>
  <div id="countdownOverlay"></div>

  <script>
    /* Caroling metronome app - single-file, no external assets
       - Transparent background so it works as an overlay / iframe
       - Uses WebAudio for low-latency timing
       - Listens for E to start if enabled
       - Plays sounds for D F J K when active
    */

    // UI elements
    const openSettings = document.getElementById('openSettings');
    const settings = document.getElementById('settings');
    const enabledBtn = document.getElementById('enabledBtn');
    const autoStartBtn = document.getElementById('autoStartBtn');
    const metronomeBtn = document.getElementById('metronomeBtn');
    const musicBtn = document.getElementById('musicBtn');
    const countdownBtn = document.getElementById('countdownBtn');
    const bpmRange = document.getElementById('bpmRange');
    const bpmVal = document.getElementById('bpmVal');
    const preset = document.getElementById('preset');
    const volume = document.getElementById('volume');
    const statTxt = document.getElementById('statTxt');
    const testSound = document.getElementById('testSound');
    const stopAll = document.getElementById('stopAll');
    const closeSettings = document.getElementById('closeSettings');
    const resetSettings = document.getElementById('resetSettings');
    const countdownOverlay = document.getElementById('countdownOverlay');

    // state
    let state = {
      enabled: false,
      autoStart: true,
      metronome: true,
      music: false,
      countdown: true,
      bpm: 85,
      preset: 'classic',
      vol: 0.6,
      running: false
    };

    function updateUI(){
      enabledBtn.textContent = state.enabled ? 'On' : 'Off';
      autoStartBtn.textContent = state.autoStart ? 'On' : 'Off';
      metronomeBtn.textContent = state.metronome ? 'On' : 'Off';
      musicBtn.textContent = state.music ? 'On' : 'Off';
      countdownBtn.textContent = state.countdown ? 'On' : 'Off';
      bpmRange.value = state.bpm;
      bpmVal.textContent = state.bpm + ' BPM';
      preset.value = state.preset;
      volume.value = state.vol;
      statTxt.textContent = state.running ? 'Active — Listening (D,F,J,K)' : (state.enabled ? 'Enabled (waiting for E)' : 'Disabled');
    }
    updateUI();

    // toggle helpers
    enabledBtn.onclick = ()=>{ state.enabled = !state.enabled; updateUI(); }
    autoStartBtn.onclick = ()=>{ state.autoStart = !state.autoStart; updateUI(); }
    metronomeBtn.onclick = ()=>{ state.metronome = !state.metronome; updateUI(); }
    musicBtn.onclick = ()=>{ state.music = !state.music; if(state.music) startMusicLoop(); else stopMusicLoop(); updateUI(); }
    countdownBtn.onclick = ()=>{ state.countdown = !state.countdown; updateUI(); }
    bpmRange.oninput = (e)=>{ state.bpm = Number(e.target.value); updateUI(); }
    preset.onchange = (e)=>{ state.preset = e.target.value; }
    volume.oninput = (e)=>{ state.vol = Number(e.target.value); }

    openSettings.onclick = ()=>{ settings.style.display = (settings.style.display === 'none' ? 'block' : 'none'); }
    closeSettings.onclick = ()=>{ settings.style.display = 'none'; }
    resetSettings.onclick = ()=>{ state = { enabled:false, autoStart:true, metronome:true, music:false, countdown:true, bpm:85, preset:'classic', vol:0.6, running:false }; updateUI(); stopAllAudio(); }

    testSound.onclick = ()=>{ makeClickAtTime(audioCtx.currentTime + 0.02, 'accent'); }
    stopAll.onclick = ()=>{ stopAllAudio(); }

    // Make settings draggable
    (function makeDraggable(node, handle){
      handle = handle || node;
      let dragging=false, startX=0, startY=0, origX=0, origY=0;
      handle.addEventListener('pointerdown', e=>{dragging=true; startX=e.clientX; startY=e.clientY; origX=parseFloat(node.style.right||'12'); origY=parseFloat(node.style.top||'56'); handle.setPointerCapture(e.pointerId)});
      window.addEventListener('pointermove', e=>{ if(!dragging) return; const dx = e.clientX - startX; const dy = e.clientY - startY; node.style.right = (origX - dx) + 'px'; node.style.top = (origY + dy) + 'px'; });
      window.addEventListener('pointerup', ()=>{dragging=false});
    })(settings, openSettings);

    // Audio setup
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let masterGain = audioCtx.createGain(); masterGain.gain.value = state.vol; masterGain.connect(audioCtx.destination);

    // Keep master gain synced
    volume.addEventListener('input', ()=>{ masterGain.gain.value = Number(volume.value); });

    // scheduling metronome using scheduler pattern for accurate timing
    let lookahead = 25.0; // ms
    let scheduleAheadTime = 0.1; // seconds
    let currentNoteTime = 0.0;
    let tempo = state.bpm;
    let timerID = null;

    function nextNote(){
      const secondsPerBeat = 60.0 / state.bpm;
      currentNoteTime += secondsPerBeat; // one note per beat
    }

    function scheduler(){
      while(currentNoteTime < audioCtx.currentTime + scheduleAheadTime){
        // schedule click at currentNoteTime
        if(state.metronome && state.running){
          makeClickAtTime(currentNoteTime, 'regular');
        }
        // advance
        nextNote();
      }
    }

    function startScheduler(){
      if(timerID) return;
      currentNoteTime = audioCtx.currentTime + 0.05;
      timerID = setInterval(scheduler, lookahead);
    }
    function stopScheduler(){ if(timerID){ clearInterval(timerID); timerID = null; } }

    // Produce click sound based on preset and type
    function makeClickAtTime(time, type){
      const g = audioCtx.createGain();
      g.gain.value = 0.0001; g.connect(masterGain);

      const osc = audioCtx.createOscillator();
      let freq = 1000;
      if(state.preset === 'classic'){ freq = (type==='accent')?1400:1000; }
      else if(state.preset === 'soft'){ freq = (type==='accent')?900:600; }
      else if(state.preset === 'synth'){ freq = (type==='accent')?1800:1200; }
      osc.frequency.value = freq;

      // short attack-decay
      const now = time;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(state.vol, now + 0.001);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);

      osc.connect(g);
      osc.start(now);
      osc.stop(now + 0.13);
    }

    // Key sounds (D F J K)
    const keyMap = {
      'd': {freq:440},
      'f': {freq:523.25},
      'j': {freq:659.25},
      'k': {freq:783.99}
    };
    function playKeySound(key){
      const k = key.toLowerCase();
      if(!keyMap[k]) return;
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain(); g.gain.value = 0.0001; g.connect(masterGain);
      const osc = audioCtx.createOscillator(); osc.type = (state.preset==='synth') ? 'sawtooth' : 'sine';
      const base = keyMap[k].freq;
      // small preset-based detune
      let freq = base;
      if(state.preset === 'classic') freq = base;
      else if(state.preset === 'soft') freq = base * 0.95;
      else if(state.preset === 'synth') freq = base * 1.02;
      osc.frequency.value = freq;

      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(state.vol * 1.2, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);

      osc.connect(g);
      osc.start(now);
      osc.stop(now + 0.4);
    }

    // Very simple music loop (when user toggles Music). It's a gentle arpeggio made with oscillators.
    let musicInterval = null;
    function startMusicLoop(){
      if(musicInterval) return;
      const chord = [440, 554.37, 659.25];
      let i = 0;
      musicInterval = setInterval(()=>{
        const now = audioCtx.currentTime;
        const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.value = chord[i%chord.length];
        const g = audioCtx.createGain(); g.gain.value = 0.0001; g.connect(masterGain);
        g.gain.exponentialRampToValueAtTime(state.vol * 0.2, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
        o.connect(g); o.start(now); o.stop(now + 0.65);
        i++;
      }, 450);
    }
    function stopMusicLoop(){ if(musicInterval){ clearInterval(musicInterval); musicInterval = null; } }

    function stopAllAudio(){ stopScheduler(); stopMusicLoop(); state.running=false; updateUI(); }

    // Handle pressing E to start
    function tryStartFromE(){
      if(!state.enabled) return;
      if(!state.autoStart) return;
      if(state.running) return; // already running

      // resume AudioContext on user gesture
      if(audioCtx.state === 'suspended') audioCtx.resume();

      const start = ()=>{
        state.running = true; updateUI();
        // start scheduling
        currentNoteTime = audioCtx.currentTime + 0.05;
        startScheduler();
      };

      if(state.countdown){
        runCountdown(3, start);
      } else start();
    }

    // Countdown visual + beep
    function runCountdown(secs, onDone){
      countdownOverlay.style.display = 'block';
      let n=secs;
      countdownOverlay.textContent = n;
      const tick = ()=>{
        if(n<=0){ countdownOverlay.style.display='none'; if(onDone) onDone(); return; }
        countdownOverlay.textContent = n; makeClickAtTime(audioCtx.currentTime + 0.02, 'accent'); n--; setTimeout(tick, 433);
      };
      tick();
    }

    // Listen for keydowns
    window.addEventListener('keydown', (e)=>{
      // If focus is inside an input, ignore
      const tag = document.activeElement && document.activeElement.tagName.toLowerCase();
      if(tag === 'input' || tag === 'textarea' || tag === 'select') return;

      if(e.key.toLowerCase() === 'e'){
        // Start/stop toggle when pressing E if enabled
        if(!state.enabled) return;
        if(state.running){ stopAllAudio(); }
        else { tryStartFromE(); }
      }

      if(state.running){
        const k = e.key.toLowerCase();
        if(['d','f','j','k'].includes(k)){
          // play assigned key sound
          if(audioCtx.state === 'suspended') audioCtx.resume();
          playKeySound(k);
        }
      }
    });

    // Also provide on-screen start/stop for testing
    document.body.addEventListener('dblclick', ()=>{
      if(!state.enabled) return;
      if(state.running) stopAllAudio(); else tryStartFromE();
    });

    // make sure UI reflects masterGain changes
    function persistStateToUI(){ masterGain.gain.value = state.vol; }

    // initial persistence
    persistStateToUI();

    // ensure audio context resumed on first user gesture anywhere in the app
    ['pointerdown','keydown'].forEach(evt=>{ window.addEventListener(evt, ()=>{ if(audioCtx.state === 'suspended') audioCtx.resume(); }, {once:true}); });

    // small accessibility: show status on load
    updateUI();

    // END
  </script>
</body>
</html>

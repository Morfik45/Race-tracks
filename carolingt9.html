<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Caroling</title>
  <style>
    /* Transparent background so the app can be embedded in-game as an overlay */
    html,body{height:100%;margin:0;background:transparent}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#eaeaea}

    /* Floating settings button */
    #openSettings{
      position:fixed;right:12px;top:12px;z-index:9999;background:rgba(0,0,0,0.45);backdrop-filter:blur(4px);
      border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;cursor:pointer
    }

    /* Settings panel (draggable) */
    #settings{
      position:fixed;right:12px;top:56px;width:320px;z-index:9999;background:rgba(10,10,10,0.72);
      border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 8px 30px rgba(0,0,0,0.6);
      display:none;color:#ddd
    }
    #settings h2{margin:0 0 8px;font-size:16px}
    .row{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
    .row label{font-size:13px}
    .toggle{cursor:pointer;padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}

    /* small helper */
    .small{font-size:12px;opacity:0.8}
    select,input[type=range]{width:100%}

    #status {
      position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);
      color:#dfe6ff;font-size:13px;z-index:9999
    }

    /* Countdown overlay */
    #countdownOverlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:72px;color:white;text-shadow:0 2px 12px rgba(0,0,0,0.8);display:none;z-index:10000}

    /* tiny controls inside settings */
    .controls{margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:8px}
    button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:inherit;cursor:pointer}
  </style>
</head>
<body>
  <button id="openSettings">‚öôÔ∏è Caroling audio settings</button>

  <div id="settings" role="dialog" aria-label="Caroling settings">
    <h2>Caroling audio app</h2>
    <div class="row"><label>Enabled (master)</label><button id="enabledBtn" class="toggle">Off</button></div>
    <div class="row"><label>Auto-start on E press</label><button id="autoStartBtn" class="toggle">On</button></div>
    <div class="row"><label>Metronome</label><button id="metronomeBtn" class="toggle">On</button></div>
    <div class="row"><label>Countdown before start</label><button id="countdownBtn" class="toggle">On</button></div>

    <div style="margin-top:10px">
      <label class="small">BPM</label>
      <input id="bpmRange" type="range" min="40" max="200" value="85">
      <div class="small" style="text-align:right" id="bpmVal">85 BPM</div>
    </div>

    <div style="margin-top:10px">
      <label class="small">Sound preset</label>
      <select id="preset">
        <option value="classic">Classic clicks (metronome + beeps)</option>
        <option value="soft">Soft wood + chime</option>
        <option value="synth">Synth clicks (electronic)</option>
      </select>
    </div>

    <div style="margin-top:10px">
      <label class="small">Volume</label>
      <input id="volume" type="range" min="0" max="1" step="0.01" value="0.6">
    </div>

    <div class="controls">
      <button id="testSound">Test sound</button>
      <button id="stopAll">Stop</button>
      <button id="closeSettings">Close</button>
      <button id="resetSettings">Reset</button>
    </div>

    <div style="margin-top:8px;font-size:12px;color:#bfc7d6;">When enabled, press <strong>E</strong> in-game to trigger the app. While active the app listens to D F J K and plays assigned sounds for each key.</div>
  </div>

  <div id="status">Status: <span id="statTxt">Disabled</span></div>
  <div id="countdownOverlay"></div>

  <script>

    let trigger_QTE = 0;
    // Register QTE trigger
window.parent.postMessage(
  {
    type: 'registerTrigger',
    trigger: 'QTE',
    name: 'Start Caroling QTE'
  },
  '*'
);
    
    /* Caroling metronome app - single-file, no external assets
       - Transparent background so it works as an overlay / iframe
       - Uses WebAudio for low-latency timing
       - Listens for E to start if enabled
       - Plays sounds for D F J K when active
    */

    // UI elements
    const openSettings = document.getElementById('openSettings');
    const settings = document.getElementById('settings');
    const enabledBtn = document.getElementById('enabledBtn');
    const autoStartBtn = document.getElementById('autoStartBtn');
    const metronomeBtn = document.getElementById('metronomeBtn');
    const countdownBtn = document.getElementById('countdownBtn');
    const bpmRange = document.getElementById('bpmRange');
    const bpmVal = document.getElementById('bpmVal');
    const preset = document.getElementById('preset');
    const volume = document.getElementById('volume');
    const statTxt = document.getElementById('statTxt');
    const testSound = document.getElementById('testSound');
    const stopAll = document.getElementById('stopAll');
    const closeSettings = document.getElementById('closeSettings');
    const resetSettings = document.getElementById('resetSettings');
    const countdownOverlay = document.getElementById('countdownOverlay');

    // state
    let state = {
      enabled: true,
      autoStart: true,
      metronome: true,
      countdown: true,
      bpm: 85,
      preset: 'classic',
      vol: 0.6,
      running: false
    };

    function updateUI(){
      enabledBtn.textContent = state.enabled ? 'On' : 'Off';
      autoStartBtn.textContent = state.autoStart ? 'On' : 'Off';
      metronomeBtn.textContent = state.metronome ? 'On' : 'Off';
      countdownBtn.textContent = state.countdown ? 'On' : 'Off';
      bpmRange.value = state.bpm;
      bpmVal.textContent = state.bpm + ' BPM';
      preset.value = state.preset;
      volume.value = state.vol;
      statTxt.textContent = state.running ? 'Active ‚Äî Listening (D,F,J,K)' : (state.enabled ? 'Enabled (waiting for E)' : 'Disabled');
    }
    updateUI();

    // toggle helpers
    enabledBtn.onclick = ()=>{ state.enabled = !state.enabled; updateUI(); }
    autoStartBtn.onclick = ()=>{ state.autoStart = !state.autoStart; updateUI(); }
    metronomeBtn.onclick = ()=>{ state.metronome = !state.metronome; updateUI(); }
    countdownBtn.onclick = ()=>{ state.countdown = !state.countdown; updateUI(); }
    bpmRange.oninput = (e)=>{ state.bpm = Number(e.target.value); updateUI(); }
    preset.onchange = (e)=>{ state.preset = e.target.value; }
    volume.oninput = (e)=>{ state.vol = Number(e.target.value); }

    openSettings.onclick = ()=>{ settings.style.display = (settings.style.display === 'none' ? 'block' : 'none'); }
    closeSettings.onclick = ()=>{ settings.style.display = 'none'; }
    resetSettings.onclick = ()=>{ state = { enabled:false, autoStart:true, metronome:true, music:false, countdown:true, bpm:85, preset:'classic', vol:0.6, running:false }; updateUI(); stopAllAudio(); }

    testSound.onclick = ()=>{ makeClickAtTime(audioCtx.currentTime + 0.02, 'accent'); }
    stopAll.onclick = ()=>{ stopAllAudio(); }

    // Audio setup
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let masterGain = audioCtx.createGain(); masterGain.gain.value = state.vol; masterGain.connect(audioCtx.destination);

    // Keep master gain synced
    volume.addEventListener('input', ()=>{ masterGain.gain.value = Number(volume.value); });

    // scheduling metronome using scheduler pattern for accurate timing
    let lookahead = 25.0; // ms
    let scheduleAheadTime = 0.1; // seconds
    let currentNoteTime = 0.0;
    let tempo = state.bpm;
    let timerID = null;

    function nextNote(){
      const secondsPerBeat = 60.0 / state.bpm;
      currentNoteTime += secondsPerBeat; // one note per beat
    }

    function scheduler(){
      while(currentNoteTime < audioCtx.currentTime + scheduleAheadTime){
        // schedule click at currentNoteTime
        if(state.metronome && state.running){
          makeClickAtTime(currentNoteTime, 'regular');
        }
        // advance
        nextNote();
      }
    }

   function startScheduler(){
  if(timerID) return;

  currentNoteTime = audioCtx.currentTime + 0.05;

  // üöÄ Show GO! exactly when the first tick is scheduled
  showGo();

  timerID = setInterval(scheduler, lookahead);
}
    function stopScheduler(){ if(timerID){ clearInterval(timerID); timerID = null; } }

    // Produce click sound based on preset and type
    function makeClickAtTime(time, type){
      const g = audioCtx.createGain();
      g.gain.value = 0.0001; g.connect(masterGain);

      const osc = audioCtx.createOscillator();
      let freq = 1000;
      if(state.preset === 'classic'){ freq = (type==='accent')?1400:1000; }
      else if(state.preset === 'soft'){ freq = (type==='accent')?900:600; }
      else if(state.preset === 'synth'){ freq = (type==='accent')?1800:1200; }
      osc.frequency.value = freq;

      // short attack-decay
      const now = time;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(state.vol, now + 0.001);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);

      osc.connect(g);
      osc.start(now);
      osc.stop(now + 0.13);
    }

    // Key sounds (D F J K)
    const keyMap = {
      'd': {freq:440},
      'f': {freq:523.25},
      'j': {freq:659.25},
      'k': {freq:783.99}
    };
    function playKeySound(key){
      const k = key.toLowerCase();
      if(!keyMap[k]) return;
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain(); g.gain.value = 0.0001; g.connect(masterGain);
      const osc = audioCtx.createOscillator(); osc.type = (state.preset==='synth') ? 'sawtooth' : 'sine';
      const base = keyMap[k].freq;
      // small preset-based detune
      let freq = base;
      if(state.preset === 'classic') freq = base;
      else if(state.preset === 'soft') freq = base * 0.95;
      else if(state.preset === 'synth') freq = base * 1.02;
      osc.frequency.value = freq;

      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(state.vol * 1.2, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);

      osc.connect(g);
      osc.start(now);
      osc.stop(now + 0.4);
    }



    function stopAllAudio(){ stopScheduler(); stopMusicLoop(); state.running=false; updateUI(); }

    // Handle pressing E to start
function tryStartFromE(){
  if(!state.enabled) return;
  if(!state.autoStart) return;
  if(state.running) return; // already running

  if(audioCtx.state === 'suspended') audioCtx.resume();

  const start = ()=>{
    state.running = true;
    miniGameActive = true;
    updateUI();

    // Start scheduler
    currentNoteTime = audioCtx.currentTime + 0.05;
    startScheduler();

    // Auto-stop after 10 notes
    const noteDuration = 60 / state.bpm;   // seconds per beat
    const totalDuration = noteDuration * 10 * 1000; // ms
    miniGameStopTimeout = setTimeout(() => stopMiniGame(), totalDuration);
  };

  if(state.countdown){
    runCountdown(2, start); // countdown from 2
  } else start();
}

// Countdown visual (no beep)
function runCountdown(secs, onDone){
  countdownOverlay.style.display = 'block';
  let n=secs;
  countdownOverlay.textContent = n;
  const tick = ()=>{
    if(n<=0){
      countdownOverlay.style.display='none';
      if(onDone) onDone();
      return;
    }
    countdownOverlay.textContent = n;
    // makeClickAtTime(audioCtx.currentTime + 0.02, 'accent'); // ‚Üê removed beep
    n--;
    setTimeout(tick, 650);
  };
  tick();
}

function showGo(){
  countdownOverlay.textContent = "GO!";
  countdownOverlay.style.display = "block";
  setTimeout(()=> countdownOverlay.style.display='none', 500); // hide after 0.5s
}
    
    // Listen for keydowns
let miniGameActive = false;
let miniGameStopTimeout = null;

window.addEventListener('message', (event) => {
  const data = event.data;
  if(data.type === 'userapp_trigger' && data.trigger === 'QTE'){
    tryStartFromE(); // your existing function to start countdown/metronome/music
  }
});

// Handle mini-game keys
window.addEventListener('keydown', (e) => {
    if(!miniGameActive) return;
    const k = e.key.toLowerCase();
    if(['d','f','j','k'].includes(k)){
        if(audioCtx.state === 'suspended') audioCtx.resume();
        playKeySound(k);
    }
});

    // Also provide on-screen start/stop for testing
    document.body.addEventListener('dblclick', ()=>{
      if(!state.enabled) return;
      if(state.running) stopAllAudio(); else tryStartFromE();
    });
function stopMiniGame(){
  miniGameActive = false;
  state.running = false;
  updateUI();
  stopScheduler();

  if(miniGameStopTimeout){
    clearTimeout(miniGameStopTimeout);
    miniGameStopTimeout = null;
  }
}
    // make sure UI reflects masterGain changes
    function persistStateToUI(){ masterGain.gain.value = state.vol; }

    // initial persistence
    persistStateToUI();

    // ensure audio context resumed on first user gesture anywhere in the app
    ['pointerdown','keydown'].forEach(evt=>{ window.addEventListener(evt, ()=>{ if(audioCtx.state === 'suspended') audioCtx.resume(); }, {once:true}); });

    // small accessibility: show status on load
    updateUI();
 // Handle Escape key for pinning
    window.addEventListener('keydown', (e) => {
        if (e.key === "Escape") {
            window.parent.postMessage({ type: "pin" }, "*");
        }
    });
    // END
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Caroling</title>
  <style>
    html,body{height:100%;margin:0;background:transparent}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#eaeaea}
    #debug {
      position:fixed;left:12px;top:12px;z-index:10001;background:rgba(0,0,0,0.65);
      padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);width:360px;color:#dff;
      font-size:12px;max-height:60vh;overflow:auto;
    }
    #openSettings{
      position:fixed;right:12px;top:12px;z-index:9999;background:rgba(0,0,0,0.45);backdrop-filter:blur(4px);
      border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;cursor:pointer;
      user-select:none;
    }
    #settings{
      position:fixed;right:12px;top:56px;width:320px;z-index:9999;background:rgba(10,10,10,0.72);
      border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 8px 30px rgba(0,0,0,0.6);
      display:none;color:#ddd
    }
    #settings h2{margin:0 0 8px;font-size:16px}
    .row{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
    .row label{font-size:13px}
    .toggle{cursor:pointer;padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}
    .small{font-size:12px;opacity:0.8}
    select,input[type=range]{width:100%}
    #status {
      position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);
      color:#dfe6ff;font-size:13px;z-index:9999
    }
    #countdownOverlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:72px;color:white;text-shadow:0 2px 12px rgba(0,0,0,0.8);display:none;z-index:10000}
    .controls{margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:8px}
    button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:inherit;cursor:pointer}
    pre {white-space:pre-wrap;word-break:break-word;margin:4px 0;font-size:11px;}
  </style>
</head>
<body>
  <div id="debug" aria-hidden="false">
    <strong>Debug panel</strong>
    <div style="margin-top:6px">
      <button id="simulateTrigger">Simulate trigger_qte</button>
      <button id="simulateD">Simulate trigger_QTED</button>
      <button id="clearDebug">Clear</button>
    </div>
    <div style="margin-top:8px"><strong>Last message origin:</strong> <span id="lastOrigin">—</span></div>
    <div style="margin-top:6px"><strong>Last payload:</strong>
      <pre id="lastPayload">—</pre>
    </div>
    <div style="margin-top:6px"><strong>Last action:</strong> <span id="lastAction">—</span></div>
    <div style="margin-top:6px;color:#cfe"><strong>Hints:</strong>
      <ul>
        <li>FiveM sends triggers wrapped in an object (we search the full message tree).</li>
        <li>Bind examples: bind keyboard e "userapp_trigger QTE", bind keyboard d "userapp_trigger QTED" etc.</li>
      </ul>
    </div>
  </div>

  <button id="openSettings">⚙️ Caroling audio settings</button>

  <div id="settings" role="dialog" aria-label="Caroling settings">
    <h2>Caroling audio app</h2>
    <div class="row"><label>Enabled (master)</label><button id="enabledBtn" class="toggle">On</button></div>
    <div class="row"><label>Auto-start on E press</label><button id="autoStartBtn" class="toggle">On</button></div>
    <div class="row"><label>Metronome</label><button id="metronomeBtn" class="toggle">On</button></div>
    <div class="row"><label>Countdown before start</label><button id="countdownBtn" class="toggle">On</button></div>

    <div style="margin-top:10px">
      <label class="small">BPM</label>
      <input id="bpmRange" type="range" min="40" max="200" value="85">
      <div class="small" style="text-align:right" id="bpmVal">85 BPM</div>
    </div>

    <div style="margin-top:10px">
      <label class="small">Sound preset</label>
      <select id="preset">
        <option value="classic">Classic clicks (metronome + beeps)</option>
        <option value="soft">Soft wood + chime</option>
        <option value="synth">Synth clicks (electronic)</option>
      </select>
    </div>

    <div style="margin-top:10px">
      <label class="small">Volume</label>
      <input id="volume" type="range" min="0" max="1" step="0.01" value="0.6">
    </div>

    <div class="controls">
      <button id="testSound">Test sound</button>
      <button id="stopAll">Stop</button>
      <button id="closeSettings">Close</button>
      <button id="resetSettings">Reset</button>
    </div>

    <div style="margin-top:8px;font-size:12px;color:#bfc7d6;">When enabled, press <strong>E</strong> in-game to trigger the app. While active the app listens to D F J K and plays assigned sounds.</div>
  </div>

  <div id="status">Status: <span id="statTxt">Disabled</span></div>
  <div id="countdownOverlay" aria-hidden="true"></div>

  <script>
    // Register QTE trigger (lowercase 'qte' -> FiveM will send trigger_qte)
    window.parent.postMessage({
      type: 'registerTrigger',
      trigger: 'qte',
      name: 'Start Caroling QTE'
    }, '*');

    // UI / state elements
    const openSettings = document.getElementById('openSettings');
    const settings = document.getElementById('settings');
    const enabledBtn = document.getElementById('enabledBtn');
    const autoStartBtn = document.getElementById('autoStartBtn');
    const metronomeBtn = document.getElementById('metronomeBtn');
    const countdownBtn = document.getElementById('countdownBtn');
    const bpmRange = document.getElementById('bpmRange');
    const bpmVal = document.getElementById('bpmVal');
    const preset = document.getElementById('preset');
    const volume = document.getElementById('volume');
    const statTxt = document.getElementById('statTxt');
    const testSound = document.getElementById('testSound');
    const stopAll = document.getElementById('stopAll');
    const closeSettings = document.getElementById('closeSettings');
    const resetSettings = document.getElementById('resetSettings');
    const countdownOverlay = document.getElementById('countdownOverlay');

    // debug elements
    const lastOrigin = document.getElementById('lastOrigin');
    const lastPayload = document.getElementById('lastPayload');
    const lastAction = document.getElementById('lastAction');
    const simulateTrigger = document.getElementById('simulateTrigger');
    const simulateD = document.getElementById('simulateD');
    const clearDebug = document.getElementById('clearDebug');

    let state = {
      enabled: true,
      autoStart: true,
      metronome: true,
      countdown: true,
      bpm: 85,
      preset: 'classic',
      vol: 0.6,
      running: false
    };

    function updateUI(){
      enabledBtn.textContent = state.enabled ? 'On' : 'Off';
      autoStartBtn.textContent = state.autoStart ? 'On' : 'Off';
      metronomeBtn.textContent = state.metronome ? 'On' : 'Off';
      countdownBtn.textContent = state.countdown ? 'On' : 'Off';
      bpmRange.value = state.bpm;
      bpmVal.textContent = state.bpm + ' BPM';
      preset.value = state.preset;
      volume.value = state.vol;
      statTxt.textContent = state.running ? 'Active — Listening (D,F,J,K)' : (state.enabled ? 'Enabled (waiting for E or trigger_qte)' : 'Disabled');
    }
    updateUI();

    enabledBtn.onclick = ()=>{ state.enabled = !state.enabled; updateUI(); logAction('Enabled set to ' + state.enabled); }
    autoStartBtn.onclick = ()=>{ state.autoStart = !state.autoStart; updateUI(); logAction('AutoStart set to ' + state.autoStart); }
    metronomeBtn.onclick = ()=>{ state.metronome = !state.metronome; updateUI(); logAction('Metronome set to ' + state.metronome); }
    countdownBtn.onclick = ()=>{ state.countdown = !state.countdown; updateUI(); logAction('Countdown set to ' + state.countdown); }
    bpmRange.oninput = (e)=>{ state.bpm = Number(e.target.value); updateUI(); logAction('BPM ' + state.bpm); }
    preset.onchange = (e)=>{ state.preset = e.target.value; logAction('Preset ' + state.preset); }
    volume.oninput = (e)=>{ state.vol = Number(e.target.value); masterGain.gain.value = state.vol; logAction('Volume ' + state.vol); }
    openSettings.onclick = ()=>{ settings.style.display = (settings.style.display==='none'?'block':'none'); }
    closeSettings.onclick = ()=>{ settings.style.display='none'; }
    resetSettings.onclick = ()=>{
      state = { enabled:true, autoStart:true, metronome:true, countdown:true, bpm:85, preset:'classic', vol:0.6, running:false };
      updateUI();
      stopAllAudio();
      logAction('Settings reset');
    }
    testSound.onclick = ()=>{ makeClickAtTime(audioCtx.currentTime + 0.02,'accent'); }
    stopAll.onclick = ()=>{ stopAllAudio(); logAction('Stopped audio'); }

    // Audio
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    let masterGain = audioCtx.createGain(); masterGain.gain.value = state.vol; masterGain.connect(audioCtx.destination);

    let lookahead = 25.0;
    let scheduleAheadTime = 0.1;
    let currentNoteTime = 0.0;
    let timerID = null;

    function nextNote(){ currentNoteTime += 60.0/state.bpm; }

    function scheduler(){
      while(currentNoteTime < audioCtx.currentTime + scheduleAheadTime){
        if(state.metronome && state.running) makeClickAtTime(currentNoteTime,'regular');
        nextNote();
      }
    }

    function startScheduler(){ 
      if(timerID) return; 
      currentNoteTime = audioCtx.currentTime + 0.05; 
      // don't call showGo here (we show GO in runCountdown or when starting immediately)
      timerID = setInterval(scheduler, lookahead);
    }
    function stopScheduler(){ if(timerID){ clearInterval(timerID); timerID=null; } }

    function makeClickAtTime(time,type){
      const g = audioCtx.createGain(); g.gain.value=0.0001; g.connect(masterGain);
      const osc = audioCtx.createOscillator();
      let freq = 1000;
      if(state.preset==='classic') freq=(type==='accent')?1400:1000;
      else if(state.preset==='soft') freq=(type==='accent')?900:600;
      else if(state.preset==='synth') freq=(type==='accent')?1800:1200;
      osc.frequency.value = freq;
      const now=time;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(state.vol, now+0.001);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
      osc.connect(g); osc.start(now); osc.stop(now+0.13);
    }

      const keyMap = {
        d: { freq: 440.00 },   // A4
        f: { freq: 493.88 },   // B4
        j: { freq: 587.33 },   // D5
        k: { freq: 659.25 }    // E5
    };
    function playKeySound(key){
      const k = String(key).toLowerCase(); if(!keyMap[k]) return;
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain(); g.gain.value=0.0001; g.connect(masterGain);
      const osc = audioCtx.createOscillator(); osc.type=(state.preset==='synth')?'sawtooth':'sine';
      let freq = keyMap[k].freq;
      if(state.preset==='soft') freq*=0.95; else if(state.preset==='synth') freq*=1.02;
      osc.frequency.value=freq;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(state.vol*1.2, now+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.35);
      osc.connect(g); osc.start(now); osc.stop(now+0.4);
    }

    function stopAllAudio(){ stopScheduler(); stopMiniGame(); }

    function runCountdown(secs,onDone){
      countdownOverlay.style.display='block';
      countdownOverlay.setAttribute('aria-hidden','false');
      let n=secs;
      countdownOverlay.textContent=n;
      const tick = ()=>{
        if(n<=0){
          // show GO at the exact moment we start the metronome
          countdownOverlay.textContent = 'GO!';
          countdownOverlay.style.display = 'block';
          countdownOverlay.setAttribute('aria-hidden','false');
          // start immediately, let overlay remain visible briefly
          if(onDone) {
            try { onDone(); } catch(err){ console.warn('onDone error',err); }
          }
          setTimeout(()=>{
            countdownOverlay.style.display='none';
            countdownOverlay.setAttribute('aria-hidden','true');
          },500);
          return;
        }
        countdownOverlay.textContent=n;
        n--;
        setTimeout(tick,650);
      };
      tick();
    }

    function showGo(){ countdownOverlay.textContent="GO!"; countdownOverlay.style.display='block'; countdownOverlay.setAttribute('aria-hidden','false'); setTimeout(()=>{ countdownOverlay.style.display='none'; countdownOverlay.setAttribute('aria-hidden','true'); },500); }

    // Debug helpers
    function logPayload(origin, payload){
      lastOrigin.textContent = origin || '—';
      try { lastPayload.textContent = JSON.stringify(payload, null, 2); } catch(e){ lastPayload.textContent = String(payload); }
    }
    function logAction(msg){
      lastAction.textContent = msg;
      console.debug('[carolingt] action:', msg);
    }
    simulateTrigger.onclick = ()=>{
      const fake = { type: 'data', data: { trigger_qte: Date.now() } };
      window.postMessage(fake, '*'); // dispatch to this window
      logAction('Simulated nested trigger posted');
    };
    simulateD.onclick = ()=>{
      const fake = { type: 'data', data: { trigger_QTED: Date.now() } };
      window.postMessage(fake, '*');
      logAction('Simulated nested trigger_QTED posted');
    };
    clearDebug.onclick = ()=>{
      lastOrigin.textContent = '—';
      lastPayload.textContent = '—';
      lastAction.textContent = '—';
    };

    // Utility: recursively search any object/array for a key starting with 'trigger_' (case-insensitive).
    // Returns the matched key (original) if found, otherwise null.
    function findTriggerKeyInTree(obj) {
      if (obj == null) return null;
      if (typeof obj !== 'object') return null;
      if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
          const res = findTriggerKeyInTree(obj[i]);
          if (res) return res;
        }
        return null;
      }
      for (const k of Object.keys(obj)) {
        try {
          const keyLower = String(k).toLowerCase();
          if (keyLower.startsWith('trigger_')) return k; // return original key
          const val = obj[k];
          if (val && typeof val === 'object') {
            const nested = findTriggerKeyInTree(val);
            if (nested) return nested;
          }
        } catch (err) {
          // ignore
        }
      }
      return null;
    }

    // Parse trigger key suffix into action: returns {type: 'start'} or {type:'key', key:'d'} or null
    function parseTriggerKeyAction(foundKey){
      if(!foundKey) return null;
      const normal = String(foundKey).toLowerCase().replace(/[^a-z0-9_]/g,'_'); // normalize
      const idx = normal.indexOf('trigger_');
      let suffix = idx>=0 ? normal.slice(idx + 'trigger_'.length) : normal;
      if (suffix === 'qte') return {type:'start'};
      const keyMatch = suffix.match(/[dfjk]/);
      if (keyMatch) {
        return {type:'key', key:keyMatch[0]};
      }
      if (['d','f','j','k'].includes(suffix)) return {type:'key', key:suffix};
      return null;
    }

    // Robust postMessage handler: accepts JSON strings, and finds trigger_* keys anywhere in the message tree
    window.addEventListener('message', e => {
      let d = e.data;
      try {
        if (typeof d === 'string') {
          const parsed = JSON.parse(d);
          if (parsed && typeof parsed === 'object') d = parsed;
        }
      } catch (err) {
        // ignore parse error
      }
      console.debug('[carolingt] postMessage from', e.origin, 'data=', d);
      logPayload(e.origin, d);

      // quick check: explicit d.trigger property
      if (d && (d.trigger === 'QTE' || d.trigger === 'qte')) {
        logAction('Detected d.trigger === QTE/qte');
        tryStartFromE();
        return;
      }

      // search the whole message tree for trigger_* key (case-insensitive)
      const foundKey = findTriggerKeyInTree(d);
      if (foundKey) {
        const action = parseTriggerKeyAction(foundKey);
        if (action) {
          if (action.type === 'start') {
            logAction('Detected trigger_qte (nested) -> starting mini-game');
            tryStartFromE();
            return;
          } else if (action.type === 'key') {
            logAction('Detected key trigger -> ' + action.key.toUpperCase());
            // Only play DFJK from remote triggers while the mini-game is active/running
            if (!miniGameActive || !state.running) {
              logAction('Ignored key trigger (mini-game not active)');
              return;
            }
            if(audioCtx.state==='suspended') {
              audioCtx.resume().catch(()=>{});
            }
            playKeySound(action.key);
            return;
          }
        } else {
          logAction('Detected trigger key but unknown action: ' + foundKey);
          return;
        }
      }
      // nothing relevant found
    });

    // Mini-game
    let miniGameActive = false;
    let miniGameStopTimeout = null;

    function tryStartFromE(){
      if(!state.enabled || state.running) {
        logAction('tryStartFromE aborted (enabled/running): ' + state.enabled + ' / ' + state.running);
        return;
      }
      if(audioCtx.state==='suspended') {
        audioCtx.resume().then(()=>console.debug('[carolingt] audioCtx resumed')).catch(err=>console.warn('[carolingt] audioCtx resume failed', err));
      }
      const start = ()=>{
        state.running=true; miniGameActive=true; updateUI();
        currentNoteTime=audioCtx.currentTime+0.05;
        // startScheduler does not show GO; show GO here so GO and first metronome tick align
        showGo();
        startScheduler();
        const noteDuration=60/state.bpm;
        miniGameStopTimeout=setTimeout(stopMiniGame,noteDuration*10*1000);
        logAction('Mini-game started');
      };
      if(state.countdown) runCountdown(2,start); else start();
    }

    function stopMiniGame(){
      miniGameActive=false; state.running=false; updateUI(); stopScheduler();
      if(miniGameStopTimeout){ clearTimeout(miniGameStopTimeout); miniGameStopTimeout=null; }
      logAction('Mini-game stopped');
    }

    // iframe-focused E key fallback
    window.addEventListener('keydown', (e)=>{
      const key = e.key && String(e.key).toLowerCase();
      if (!key) return;
      if (key === 'e') {
        if (state.autoStart) {
          logAction('E pressed in iframe; attempting auto-start');
          tryStartFromE();
        } else {
          logAction('E pressed but autoStart disabled');
        }
      }
    });

    // play key sounds while mini-game active (local keyboard)
    window.addEventListener('keydown',(e)=>{
      if(!miniGameActive) return;
      const k=e.key && e.key.toLowerCase();
      if(['d','f','j','k'].includes(k)){
        if(audioCtx.state==='suspended') audioCtx.resume();
        playKeySound(k);
      }
    });

    document.body.addEventListener('dblclick',()=>{
      if(!state.enabled) return;
      if(state.running) stopAllAudio(); else tryStartFromE();
    });

    // Resume AudioContext on first gesture
    ['pointerdown','keydown'].forEach(evt=>{ window.addEventListener(evt, ()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); }, {once:true}); });

    // existing Escape behaviour: pin parent
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') window.parent.postMessage({type:'pin'},'*'); });
  </script>
</body>
</html>
